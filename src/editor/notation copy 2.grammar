// see https://github.com/lezer-parser/julia/blob/main/src/index.grammar
// lezer-generator ./src/editor/notation.grammar -o src/editor/notation.js


@precedence {
    immediate
    dot @left
    prefix
    postfix
    interp @left
    typeonlyascription @left
    typeascription @left
    coeff
    call
    power @left
    bitshift @left
    times @left
    plus @left
    range @left
    pipe @left
    pipeback @right
    contains @left
    arrow @right
    band @right
    bor @right
    ternary @right
    pair @right
    assign @right
    regular1
    right0 @right
    regular0
    regular-1
    right-2 @right
    regular-2
  }
  
  @top SourceFile {
    topLevelList<e, pe> | ""
  }
  
  @skip { whitespace | Comment | BlockComment }
  
  // TOP LEVEL

  topLevelList<e, pe>{
    definition | CompoundExpression | FunctionAssignmentExpression
  }
  
  expressionList<e, pe> {
    (e ~id | AssignmentExpression<e> | FunctionAssignmentExpression )
    (!regular0 terminator
      (!regular0 e | AssignmentExpression<e> | FunctionAssignmentExpression ))*
    terminator?
  }
  
  BareTupleExpression<e> {
    e (!regular-1 "," e)+
  }
  
  AssignmentExpression<e> {
    ((e | BareTupleExpression<e>)
    !assign (assignOperator | "=")
    (e | AssignmentExpression<e> | BareTupleExpression<e>))
  }
  
  simpleAssignmentExpression<e> {
    e ~id !assign (assignOperator | "=") !assign e
  }
  
  simpleExpressionList<e> {
    (e ~id | AssignmentExpression { simpleAssignmentExpression<e> })
    (!regular0 terminator
      (!regular0 e | AssignmentExpression { simpleAssignmentExpression<e> }))*
    terminator?
  }
  
  FunctionAssignmentExpression[@dynamicPrecedence=2] {
    Identifier ~id immediateParen !call ArgumentList<e, pe> ~id
    !assign (assignOperator | "=")
    !assign (e | AssignmentExpression<e>)
  }

  
  // STATEMENTS
  
  statement {
    IfStatement |
    ForStatement |
    WhileStatement |
    BreakStatement |
    ContinueStatement |
    ReturnStatement
  }
  
  IfStatement[closedBy="end else elseif"] {
    kw<"if"> e terminator?
      expressionList<e, pe>?
    ElseifClause*
    ElseClause?
    end
  }
  
  ElseifClause[closedBy="end else elseif"] {
    kw<"elseif"> e terminator?
      expressionList<e, pe>?
  }
  
  ElseClause[closedBy="end"] {
    kw<"else">
      expressionList<e, pe>?
  }
  
  ForStatement[closedBy="end"] {
    !regular0 kw<"for"> ForBinding<e, pe> ("," ForBinding<e, pe>)* terminator?
      expressionList<e, pe>?
    end
  }
  
  WhileStatement[closedBy="end"] {
    !regular0 kw<"while"> !regular0 e !regular0 terminator? !regular0 expressionList<e, pe>? end
  }
  
  BreakStatement {
    kw<"break">
  }
  
  ContinueStatement {
    kw<"continue">
  }
  
  ReturnStatement {
    kw<"return"> (!right-2 (e | BareTupleExpression<e>))?
  }
  
  
  VariableDeclaration {
    (Identifier ) (!right0 "=" e)?
  }
  
  
  
  // DEFINITIONS
  
  definition {
    FunctionDefinition | InstrumentVoice
  }

  InstrumentVoice[closedBy="\n"] {
    Identifier ":" BarList terminator
  }


  BarList {
    Bar (BarLine Bar)*
  }

  BarLine {
    "|" | "|:" | ":|" | "||" | "ğ„€" | "ğ„" | "ğ„‚" | "ğ„ƒ" | "ğ„„" | "ğ„…" | "ğ„†" | "ğ„‡"
  }

  Bar {
    ( Group)*
  }

  Group {
    groupMember (nowhitespace groupMember)*
  }

  groupMember {
    Chord | Tone | Duration | Rest | SpecificRest
  }

  Chord {
    "cmin"
  }

  Tone {
    (Accidental nowhitespace)? ToneInOctave ToneOctave?
  }

  // https://en.wikipedia.org/wiki/Musical_Symbols_(Unicode_block)
  ToneInOctave {
    "a"|"b"|"c"|"d"|"e"|"f"|"g"|"h"|"A"|"B"|"C"|"D"|"E"|"F"|"G"|"H"
  }

  ToneOctave {
   ( Integer) |
   (  ",")+ | 
   (  "'")+
  }
  
  Accidental {
    "+"|"++"|
    "-"|"--"|
    "â™­"|"â™¯"|"ğ„ª"|"ğ„«"|"ğ„­"|"ğ„¯"|"ğ„®"|"ğ„°"|"ğ„±"|"ğ„²"|"ğ„³"
  }

  Rest {
    "r" 
  }
  
  SpecificRest {
    ("ğ„º"|"ğ„»"|"ğ„¼"|"ğ„½"|"ğ„¾"|"ğ„¿"|"ğ…€"|"ğ…"|"ğ…‚") Dots?
  }

  Duration {
    (("/" ("0"|"1"|"2"|"4"|"8"|"16"|"32"|"64"|"128"|"256"|"512"|"1024")) | "ğ…œ"|"ğ…"|"ğ…"|"â™©"|"â™ª"|"ğ…¡"|"ğ…¢"|"ğ…£"|"ğ…¤"|"â™¬"|"â™«") Dots?
  }

  Dots {
    (  ".")+
  }

  FunctionDefinition[closedBy="end"] {
    !regular0 (kw<"function"> | kw<"melody"> | kw<"rhythm">)
      definitionHead
      params[@dynamicPrecedence=1] {
        !immediate immediateParen !immediate ArgumentList<e, pe>
        ReturnType {
          !typeascription "::" pe
        }?
      }?
      expressionList<e, pe>? 
    end
  }  
  
  definitionHead {
    Identifier ~id |
    ParenthesizedExpression<definitionHead> |
    Operator ~op
  }
  
  
  // EXPRESSIONS
  
  e {
    statement |
    CompoundExpression |
    UnaryExpression<e> |
    BinaryExpression<e> |
    TernaryExpression<e> |
    FunctionExpression<e, pe> |
    FunctionExpression[closedBy="end"] { verboseFunctionExpression } |
    Operator[group="operator"] { ":" ~op } |
    pe
  }
  
  pe {
    CallExpression<e, pe> |
    Identifier ~id |
    Number |
    Integer |
    String |
    TupleExpression<e, pe> |
    ParenthesizedExpression<e> |
    Operator ~op
  }
  
  TernaryExpression<e> {
    e
    !ternary ternary1 !ternary
    e
    !ternary ternary2 !ternary
    e
  }
  
  
  CompoundExpression[closedBy="end"] {
    kw<"begin"> expressionList<e, pe> end
  }
  
  CallExpression<e, pe> {
    pe
    !call immediateParen
    !call args[@dynamicPrecedence=1] { ArgumentList<e, pe> }
    DoClause?
  }
  
  DoClause[closedBy="end"] {
    kw<"do"> expressionList<e, pe> end
  }
  
  ArgumentList[closedBy=")"]<e, pe> {
    "("
    (arg<e, pe> ~id ("," arg<e, pe> ~id)*)?
    (";" arg<e, pe> ("," arg<e, pe>)*)?
    ","?
    ")"
  }
  
  arg<e, pe> {
    (e | NamedArgument { NamedField<e, pe>  }) ~id
  }
  
  ParenthesizedExpression[closedBy=")"]<e> {
    "(" !regular1 simpleExpressionList<e> !regular1 ")"
  }
  
  TupleExpression[closedBy=")"]<e, pe> {
    "("
      (
      (tupleelem<e, pe> ~id !regular0 ",") |
      (tupleelem<e, pe> ~id (!regular0 "," tupleelem<e, pe> ~id)+ ","?)
      )?
    ")"
  }
  
  tupleelem<e, pe> {
    e | NamedField<e, pe>
  }
  
  NamedField<e, pe> {
    name { Identifier  } ~id !assign "=" e
  }
  
  verboseFunctionExpression {
    kw<"function"> ArgumentList<e, pe> expressionList<e, pe>? end
  }
  
  FunctionExpression<e, pe> {
    (Identifier ~id | ArgumentList<e, pe>) !arrow "->" (e | AssignmentExpression<e>)
  }
  
  BinaryExpression<e> {
    e !power powerOperator !power e |
    e !bitshift bitshiftOperator !bitshift e |
    e !times timesOperator !times e |
    e !plus ("$" | plusOperator) !plus e |
    e !arrow arrowOperator e |
    e !pipeback "<|" e |
    e !pipe "|>" e |
    e !contains (kw<"in"> | kw<"isa"> | comparisonOperator) !contains e |
    e !bor "||" e |
    e !band "&&" e
  }
  
  UnaryExpression<e> {
    (unaryOperatorExtra | plusminus) ~op !prefix e |
    e !postfix ("'" | ".'")
  }
  
  Operator[group="operator"] {
    !regular0 (
      "$" |
      "=" |
      assignOperator |
      plusOperator |
      timesOperator |
      powerOperator |
      comparisonOperator
    )
  }
  
  
  IfClause<e, pe> {
    kw<"if"> e
  }
  
  ForClause<e, pe> {
    kw<"for"> ForBinding<e, pe> (!regular0 "," ForBinding<e, pe>)*
  }
  
  ForBinding<e, pe> {
    (Identifier | TupleExpression<e, pe>) (kw<"in"> | "=" | "âˆˆ") e
  }
  
  ScopedIdentifier {
    "." !dot ScopedIdentifier |
    (Identifier | ScopedIdentifier)? !dot "." !dot Identifier
  }
  
  RangeExpression<e> {
    e !range ":" !range e
  }
  
  @skip {} {
    String {
      '"' (stringContent )* '"'
    }
   
  }
  
  
  plusOperator {
    "." !immediate nowhitespace (plusOperatorExtra | plusminus) |
    (plusOperatorExtra | plusminus)
  }
  
  end { @specialize[@name=end,group="keyword"]<Identifier, "end"> }
  kw<term> { @specialize[@name={term},group="keyword"]<Identifier, term> }
  
  @external tokens terminator from "./tokens" { terminator }
  @external tokens Identifier from "./tokens" { Identifier }
  @external tokens BlockComment from "./tokens" { BlockComment }
  @external tokens stringContent from "./tokens" { stringContent }
  @external tokens layoutExtra from "./tokens" {
    immediateParen,
    immediateColon,
    immediateBrace,
    immediateBracket,
    immediateDoubleQuote,
    immediateBackquote,
    immediateDot,
    nowhitespace
  }
  
  @tokens {
    whitespace {
      " " | "\t" | "\n"
    }
    Comment {
      "#" ![\n]*
    }
    Integer {
      $[0-9] $[0-9_]*
    }
    Number {
      // not-integer
      (
        "0" $[xX] $[0-9a-fA-F] $[0-9a-fA-F_]* |
        $[0-9] $[0-9_]* "." ($[0-9] $[0-9_]*)? |
        "." $[0-9] $[0-9_]*
      )
      //($[eE] ("-" | "+")? $[0-9]+)?
    }
    powerOperator {
      "."? ("^" /*| "â†‘" | "â†“" | "â‡µ" | "âŸ°" | "âŸ±" | "â¤ˆ" | "â¤‰" | "â¤Š" | "â¤‹" | "â¤’" | "â¤“" | "â¥‰" | "â¥Œ" | "â¥" | "â¥" | "â¥‘" | "â¥”" | "â¥•" | "â¥˜" | "â¥™" | "â¥œ" | "â¥" | "â¥ " | "â¥¡" | "â¥£" | "â¥¥" | "â¥®" | "â¥¯" | "ï¿ª" | "ï¿¬"*/)
    }
    timesOperator {
      "."? ("*" | "/" | "Ã·" | "%" | "&" /*| "â‹…" | "âˆ˜" | "Ã—" | "\\" | "âˆ©" | "âˆ§" | "âŠ—" | "âŠ˜" | "âŠ™" | "âŠš" | "âŠ›" | "âŠ " | "âŠ¡" | "âŠ“" | "âˆ—" | "âˆ™" | "âˆ¤" | "â…‹" | "â‰€" | "âŠ¼" | "â‹„" | "â‹†" | "â‹‡" | "â‹‰" | "â‹Š" | "â‹‹" | "â‹Œ" | "â‹" | "â‹’" | "âŸ‘" | "â¦¸" | "â¦¼" | "â¦¾" | "â¦¿" | "â§¶" | "â§·" | "â¨‡" | "â¨°" | "â¨±" | "â¨²" | "â¨³" | "â¨´" | "â¨µ" | "â¨¶" | "â¨·" | "â¨¸" | "â¨»" | "â¨¼" | "â¨½" | "â©€" | "â©ƒ" | "â©„" | "â©‹" | "â©" | "â©" | "â©‘" | "â©“" | "â©•" | "â©˜" | "â©š" | "â©œ" | "â©" | "â©Ÿ" | "â© " | "â«›" | "âŠ" | "â–·" | "â¨" | "âŸ•" | "âŸ–" | "âŸ—"*/)
    }
    plusOperatorExtra {
      "|||" /*| "âŠ•" | "âŠ–" | "âŠ" | "âŠŸ" | "|++|" | "âˆª" | "âˆ¨" | "âŠ”" | "Â±" | "âˆ“" | "âˆ”" | "âˆ¸" | "â‰‚" | "â‰" | "âŠ" | "âŠ»" | "âŠ½" | "â‹" | "â‹“" | "â§º" | "â§»" | "â¨ˆ" | "â¨¢" | "â¨£" | "â¨¤" | "â¨¥" | "â¨¦" | "â¨§" | "â¨¨" | "â¨©" | "â¨ª" | "â¨«" | "â¨¬" | "â¨­" | "â¨®" | "â¨¹" | "â¨º" | "â©" | "â©‚" | "â©…" | "â©Š" | "â©Œ" | "â©" | "â©" | "â©’" | "â©”" | "â©–" | "â©—" | "â©›" | "â©" | "â©¡" | "â©¢" | "â©£"*/
    }
    arrowOperator {
      "--" | "-->" | "."?  ("â†" | "â†’" /*| "â†”" | "â†š" | "â†›" | "â†" | "â† " | "â†¢" | "â†£" | "â†¦" | "â†¤" | "â†®" | "â‡" | "â‡" | "â‡" | "â‡" | "â‡’" | "â‡”" | "â‡´" | "â‡¶" | "â‡·" | "â‡¸" | "â‡¹" | "â‡º" | "â‡»" | "â‡¼" | "â‡½" | "â‡¾" | "â‡¿" | "âŸµ" | "âŸ¶" | "âŸ·" | "âŸ¹" | "âŸº" | "âŸ»" | "âŸ¼" | "âŸ½" | "âŸ¾" | "âŸ¿" | "â¤€" | "â¤" | "â¤‚" | "â¤ƒ" | "â¤„" | "â¤…" | "â¤†" | "â¤‡" | "â¤Œ" | "â¤" | "â¤" | "â¤" | "â¤" | "â¤‘" | "â¤”" | "â¤•" | "â¤–" | "â¤—" | "â¤˜" | "â¤" | "â¤" | "â¤Ÿ" | "â¤ " | "â¥„" | "â¥…" | "â¥†" | "â¥‡" | "â¥ˆ" | "â¥Š" | "â¥‹" | "â¥" | "â¥" | "â¥’" | "â¥“" | "â¥–" | "â¥—" | "â¥š" | "â¥›" | "â¥" | "â¥Ÿ" | "â¥¢" | "â¥¤" | "â¥¦" | "â¥§" | "â¥¨" | "â¥©" | "â¥ª" | "â¥«" | "â¥¬" | "â¥­" | "â¥°" | "â§´" | "â¬±" | "â¬°" | "â¬²" | "â¬³" | "â¬´" | "â¬µ" | "â¬¶" | "â¬·" | "â¬¸" | "â¬¹" | "â¬º" | "â¬»" | "â¬¼" | "â¬½" | "â¬¾" | "â¬¿" | "â­€" | "â­" | "â­‚" | "â­ƒ" | "â­„" | "â­‡" | "â­ˆ" | "â­‰" | "â­Š" | "â­‹" | "â­Œ" | "ï¿©" | "ï¿«" | "â‡œ" | "â‡" | "â†œ" | "â†" | "â†©" | "â†ª" | "â†«" | "â†¬" | "â†¼" | "â†½" | "â‡€" | "â‡" | "â‡„" | "â‡†" | "â‡‡" | "â‡‰" | "â‡‹" | "â‡Œ" | "â‡š" | "â‡›" | "â‡ " | "â‡¢"*/)
    }
    bitshiftOperator {
      ">>" | "<<" | ">>>"
    }
    comparisonOperator {
      "|<:|" | "|>:|" | "."?  (">" | "<" | ">=" | "â‰¥" | "<=" | "â‰¤" | "==" | "===" /*| "â‰¡" | "!=" | "â‰ " | "!==" | "â‰¢" | "âˆˆ" | "âˆ‰" | "âˆ‹" | "âˆŒ" | "âŠ†" | "âŠˆ" | "âŠ‚" | "âŠ„" | "âŠŠ" | "âˆ" | "âˆŠ" | "âˆ" | "âˆ¥" | "âˆ¦" | "âˆ·" | "âˆº" | "âˆ»" | "âˆ½" | "âˆ¾" | "â‰" | "â‰ƒ" | "â‰‚" | "â‰„" | "â‰…" | "â‰†" | "â‰‡" | "â‰ˆ" | "â‰‰" | "â‰Š" | "â‰‹" | "â‰Œ" | "â‰" | "â‰" | "â‰" | "â‰‘" | "â‰’" | "â‰“" | "â‰–" | "â‰—" | "â‰˜" | "â‰™" | "â‰š" | "â‰›" | "â‰œ" | "â‰" | "â‰" | "â‰Ÿ" | "â‰£" | "â‰¦" | "â‰§" | "â‰¨" | "â‰©" | "â‰ª" | "â‰«" | "â‰¬" | "â‰­" | "â‰®" | "â‰¯" | "â‰°" | "â‰±" | "â‰²" | "â‰³" | "â‰´" | "â‰µ" | "â‰¶" | "â‰·" | "â‰¸" | "â‰¹" | "â‰º" | "â‰»" | "â‰¼" | "â‰½" | "â‰¾" | "â‰¿" | "âŠ€" | "âŠ" | "âŠƒ" | "âŠ…" | "âŠ‡" | "âŠ‰" | "âŠ‹" | "âŠ" | "âŠ" | "âŠ‘" | "âŠ’" | "âŠœ" | "âŠ©" | "âŠ¬" | "âŠ®" | "âŠ°" | "âŠ±" | "âŠ²" | "âŠ³" | "âŠ´" | "âŠµ" | "âŠ¶" | "âŠ·" | "â‹" | "â‹" | "â‹‘" | "â‹•" | "â‹–" | "â‹—" | "â‹˜" | "â‹™" | "â‹š" | "â‹›" | "â‹œ" | "â‹" | "â‹" | "â‹Ÿ" | "â‹ " | "â‹¡" | "â‹¢" | "â‹£" | "â‹¤" | "â‹¥" | "â‹¦" | "â‹§" | "â‹¨" | "â‹©" | "â‹ª" | "â‹«" | "â‹¬" | "â‹­" | "â‹²" | "â‹³" | "â‹´" | "â‹µ" | "â‹¶" | "â‹·" | "â‹¸" | "â‹¹" | "â‹º" | "â‹»" | "â‹¼" | "â‹½" | "â‹¾" | "â‹¿" | "âŸˆ" | "âŸ‰" | "âŸ’" | "â¦·" | "â§€" | "â§" | "â§¡" | "â§£" | "â§¤" | "â§¥" | "â©¦" | "â©§" | "â©ª" | "â©«" | "â©¬" | "â©­" | "â©®" | "â©¯" | "â©°" | "â©±" | "â©²" | "â©³" | "â©µ" | "â©¶" | "â©·" | "â©¸" | "â©¹" | "â©º" | "â©»" | "â©¼" | "â©½" | "â©¾" | "â©¿" | "âª€" | "âª" | "âª‚" | "âªƒ" | "âª„" | "âª…" | "âª†" | "âª‡" | "âªˆ" | "âª‰" | "âªŠ" | "âª‹" | "âªŒ" | "âª" | "âª" | "âª" | "âª" | "âª‘" | "âª’" | "âª“" | "âª”" | "âª•" | "âª–" | "âª—" | "âª˜" | "âª™" | "âªš" | "âª›" | "âªœ" | "âª" | "âª" | "âªŸ" | "âª " | "âª¡" | "âª¢" | "âª£" | "âª¤" | "âª¥" | "âª¦" | "âª§" | "âª¨" | "âª©" | "âªª" | "âª«" | "âª¬" | "âª­" | "âª®" | "âª¯" | "âª°" | "âª±" | "âª²" | "âª³" | "âª´" | "âªµ" | "âª¶" | "âª·" | "âª¸" | "âª¹" | "âªº" | "âª»" | "âª¼" | "âª½" | "âª¾" | "âª¿" | "â«€" | "â«" | "â«‚" | "â«ƒ" | "â«„" | "â«…" | "â«†" | "â«‡" | "â«ˆ" | "â«‰" | "â«Š" | "â«‹" | "â«Œ" | "â«" | "â«" | "â«" | "â«" | "â«‘" | "â«’" | "â«“" | "â«”" | "â«•" | "â«–" | "â«—" | "â«˜" | "â«™" | "â«·" | "â«¸" | "â«¹" | "â«º" | "âŠ¢" | "âŠ£" | "âŸ‚"*/)
    }
    assignOperator {
      ":=" | "~" | "$=" | "."? ("=" | "+=" | "-=" | "*=" | "/=" /*| "//=" | "|=|" | "^=" | "Ã·=" | "%=" | "<<=" | ">>=" | ">>>=" | "||=|" | "&=" | "âŠ»=" | "â‰”" | "â©´" | "â‰•"*/)
    }
    unaryOperatorExtra {
      ">:" | "!" | "~" | "Â¬" | "âˆš" | "âˆ›" | "âˆœ"
    }
    plusminus {
      "+" | "-"
    }
    ternary1 {
      whitespace+ "?" whitespace+
    }
    ternary2 {
      whitespace+ ":" whitespace+
    }
    @precedence {
      Integer,
      Number,
      comparisonOperator,
      "=",
      assignOperator,
      unaryOperatorExtra,
      plusOperatorExtra,
      ".",
      ternary1,
      ternary2,
      whitespace
    }
  }